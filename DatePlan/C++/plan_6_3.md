####  只能在栈上创建对象的类
---
- 只能在栈上创建对象，就是只能使用静态的方式创建对象，不能使用new 在堆上创建对象
- new 创建对象需要调用operator new , 只需要将operator new  和 operator delete 设置为私有即可 
    - 方法1
    ```
    class OnlyStack{
        public:
            OnlyStack(){}
            ~OnlyStack(){}
        private: 
            void * operator new(size_t size){}
            void operator delete(void *ptr){}
    };
    ```
    - 方法2
    - 构造函数私有化
    ```
    class OnlyStack{
    public:
        static OnlyStack Create(){
            return OnlyStack();
        }
    private:
        OnlyStack(){}
    };
    ```
####  只能在堆上创建对象的类
---
- 不能在栈上创建对象，只能在堆上创建对象
- 方法1: 将构造函数私有化，提供只能用new静态的创建对象的接口
```
class OnlyHeap{
    public:
        static OnlyHeap* Create(){
            return new OnlyHeap();
        }
    private:
        OnlyHeap(){}
};
```
- 方法2: 将析构函数私有化，编译器在创建对象时会检查析构函数函数的访问权限看是否能够调用，如果不能调用就无法创建。 但是实现多态时需要将析构函数设置成virtul 以完成重写。如果设置为private就无法继承，所以设置成protected 
```
class OnlyHeap{
    public:
        static OnlyHeap* Create(){
            return new OnlyHeap();
        }

        void destory(){ //通过调用在类外释放内存
            delete this;
        }
    protected:
        ~OnlyHeap(){}
};
```

#### delete this 合法吗？
---
- 合法
- 但是要保证 this 对象是由new 分配的（new 与 delete配对）。
- 保证调用delete this的成员函数是最后一个调用，后面不会再调用其他的成员函数
- 后面不再操作delete this

### ｜ 内存泄漏
---
- 是指在内存申请后没有被释放导致该内存块被永远的占用。
- 几种内存泄漏的方式：
    - 1. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。
    - 2. 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。
    - 3. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。
    - 4. 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。
    - 内存泄漏堆积导致最后系统的内存被耗尽。

#### 检测内存泄漏
---
- linux 下使用mtrace 分析内存泄漏
    - mtrace是Glibc的一部分，无须特殊安装。只要在要检测的代码中添加mtrace 钩子函数，就会生成内存分配的调试跟踪信息
    ```
    #include <mcheck.h>

    void mtrace(void); // 开启内存分配跟踪
    void muntrace(void); //取消内存分配跟踪

    #include<stdio.h>
    #include<stdlib.h>
    #include<mcheck.h>

    int main(int argc, char **argv)
    {
        mtrace();

        char *p = malloc(16);

        free(p);

        p = malloc(32);

        muntrace();

        return 0;
    }
    ``` 
    - 先定义一个环境变量来指明生成日志的路径export MALLOC_TRACE=./memleak.log
    - 然后运行程序
    - 日志内容:记录了内存的分配与释放
    ```
    = Start
    @ ./demo_mtrace_memleak:[0x7f6ca1400738] + 0x7fffc93796a0 0x10
    @ ./demo_mtrace_memleak:[0x7f6ca1400748] - 0x7fffc93796a0
    @ ./demo_mtrace_memleak:[0x7f6ca1400752] + 0x7fffc93796c0 0x20
    = End
    ```
    - 使用mtrace 命令分析日志, mtrace这个工具需要至少两个参数，一个是生成的可执行程序文件的路径，还有一个是日志文件的路径
    ```
    # mtrace ./demo $MALLOC_TRACE

    Memory not freed:   
    -----------------
              Address     Size     Caller
    0x00007fffc93796c0     0x20  at 0x7f6ca1400752
    ```
    - 可以检测未释放内存、重复释放内存
- linux 下 valgrind 中的memcheck 检测内存错误
    - 可以检测内存泄漏
    - 可以检测内未释放内存的使用
    - 对已释放的内存的读写
    - 重复释放内存
    - 不匹配使用new/new[]/delete/ delete[]/ malloc/free
    - 使用野指针（未给指针分配内存却使用了，内存已经释放继续使用该指针）
    - 动态内存越界访问
- 使用方式 linux 安装valgrind
- g++编译程序时编译加-g  命令： valgrind --tool=memcheck ./a.out  选择memcheck 工具 执行可执行程序即可, 各种内存问题均有提示
![示例](https://user-images.githubusercontent.com/38885360/120576595-a128c500-c455-11eb-8876-23754675303c.png)

#### 避免内存泄露
---
- 尽量避免在堆上分配内存
  - 既然只有堆上会发生内存泄露，那第一原则肯定是避免在堆上面进行内存分配，尽可能的使用栈上的内存，由编译器进行分配和回收
- 在return的地方检查所有内存资源
- 使用能够管理内存生命周期的方法，如RAII

#### 内存溢出
- 内存溢出：存储的数据超出了指定的空间，导致内存越界.常见的有栈溢出、缓冲区溢出
- 常见的内存溢出场景: 死循环/递归调用、从数据库中往内存中加载的数据过大（因此对于数据库查询尽量采用分页的方式查询）
- 解决：检查代码、对动态内存分配进行查看
1. 内存溢出：简单地说内存溢出就是指**程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存**，于是就发生了内存溢出。
2. 内存泄漏：内存泄漏指程序运行过程中**分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存**，既不能被使用也不能分配给其他程序，于是就发生了内存泄漏。
3. 内存越界：是指向系统申请一块内存后，使用时却超出申请范围。比如一些操作内存的函数：sprintf、strcpy、strcat、vsprintf、memcpy、memset、memmove。当造成内存泄漏的代码运行时，所带来的错误是无法避免的，通常会造成
   - 破坏了堆中内存内存分配信息数据
   - 破坏了程序其他对象的内存空间
   - 破坏了空闲内存块

> 之前就遇到一个相关的问题：

char[]与string之间转换：
char []转string：1）直接赋值；2）构造转换实现

```c++
// char[]转换为string 
char st[] = "hello"; 
// 直接赋值实现 
string st1 = st;
cout << st1 << endl;
// 构造实现 
string st2(st, st + strlen(st));
cout << st2 << endl;
```

string转char[]：拷贝实现，不能直接赋值

```c++
// string转char []
string ts = "My test1";
//char ts1[] = ts;          // 错误
//char ts1[] = const_cast<char *>(ts.c_str());   // 错误 
char ts1[] = "lalallalalaaaa";
strncpy(ts1, ts.c_str(), ts.length() + 1);       // 注意，一定要加1，否则没有赋值'\0' 
cout << ts1 << endl; 
return 0;
```

涉及到char []字符数组与其它类型转换，一般需要进行拷贝，不能直接赋值实现，正常情况下我们可以怎样用，但是char[]有个大问题，就是容量有限制，当我们进行strcpy/strncpy时，当超出数组长度时，就会程序错误了，所以有一种方式是利用strncpy限制拷贝的最长长度，即数组长度，
strncpy(ts1, ts.c_str(), ts1.size()));

### ｜ 指针与引用
---
指针是变量，存储的是地址；引用只是别名，不能为空，必须初始化，并且初始化后不能改变，不能指向其它；
指针可以有const，可以为空，可以改变指向，因为它是一个变量，如果sizeof得到的结果也不同，自增操作结果也不同，函数参数传递也不同（一个是拷贝，一个是引用传递）
如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；
#### 引用的本质
- 引用： 就是变量的别名
- 引用的本质：底层是常指针，其指向地址不能修改
```
int main(){

    //变量的引用
    int a = 1;
    int& b = a;//b 为 a 的引用
    //结构体的引用
    //指针的引用
}
``` 
- 引用必须初始化，对引用的修改就是对变量的直接修改
- 引用作为参数，使用const 引用作为参数解决大块数据传参的拷贝导致的时间空间问题，使用const 保证参数传递过程中的安全性
- **引用本身不是数据类型，只是变量的别名，底层是常指针, 引用占用的空间和指针占用的空间大小一样,但对于引用的操作和对于变量的操作一样，所以对引用& 和 对变量& 所得的结果是一样的**。
#### 指针与引用的区别
- 指针是类型， 引用不是类型只是变量的别名
- 有const 指针, 没有const 引用
- 有空指针没有空引用，引用必须初始化
- 指针的值在初始化后可以改变，但是引用在初始化后不能改变
- sizeof 对指针操作是的到指针本身的大小，对引用操作是的到所引用变量的大小
- 对指针加减操作是指针的地址加减，对引用加减操作是直接改变变量
- 指针有多级，引用没有


#####  指针传参和引用传参
- 引用传参和指针传参的效率上相差不多，因为底层是常指针
- 指针传参时传递的是指针的地址的拷贝，属于局部变量，对于指针形参的地址可以修改但不影响实参的地址值，使用引用传参，对于引用的修改，同时会修改所引用的变量

#### 空指针与野指针与空类型的指针
- 空指针：不指向任何对象或函数的内存，一般初始化指针为NULL即为空指针。
- 空指针赋值分区：进程的地址空间中从0x00000000 到 0x0000FFFF 的闭区间（64K 的内存大小 ）,为保留内存，不能访问，不能使用，用来捕获对空指针的赋值，该段逻辑地址没有实际的物理地址与之对应，所以访问空指针就会引发违规访问的异常。
- 空类型的指针：空类型的指针是指void* 的指针，不能直接对void* 的指针解引用，必须要转换成相应的类型才可以解引用

- 野指针：指向非法内存的指针变量
    - 指针变量没有初始化
    - 指针变量free/delete 后没有置为NULL
    - 指针的操作超越类变量的访问范围
    - 野指针会造成内存泄漏

空指针常量：0、0L、'\0'、3 - 3、0 * 17 （它们都是“integer constant expression”）以及 (void * *)0 等都是空指针常量。至于系统选取哪种形式作为空指针常量使用，则是实现相关的。一般的 C 系统选择 (void* * *)0 或者 0 的居多（也有个别的选择 0L）；至于 C++ 系统，由于存在严格的类型转化的要求，void* * 不能象 C 中那样自由转换为其它指针类型，所以通常选 0 作为空指针常量（C++标准推荐），而不选择 (void *)0。

空指针：指针变量指向内存中空指针常量的空间，0-255之间的内存是系统使用的，由系统保证空指针不指向任何实际的对象或者函数。反过来说，任何对象或者函数的地址都不可能是空指针。即空指针指向的内存是不允许访问的。所以用来初始化指针变量。

##### 为什么空指针访问会出现异常？
NULL指针分配的分区：其范围是从 0x00000000到0x0000FFFF。这段空间是空闲的，对于空闲的空间而言，没有相应的物理存储器与之相对应，所以对这段空间来说，任何读写操作都是会引起异常的。空指针是程序无论在何时都没有物理存储器与之对应的地址。为了保障“无论何时”这个条件，需要人为划分一个空指针的区域，固有上面NULL指针分区。
野指针：指针变量指向的是一块非法的内存空间，野指针不是NULL指针，是指向“垃圾”内存的指针。产生野指针的几种情况：
1. 指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如：
   ```c++
   char *p = NULL;
   char *str = (char *) malloc(100);
   ```
2. 指针指向的空间被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。
3. 指针操作超越了变量的作用范围。示例程序如下：
   ```c++
   class A 
   {      
   public:
        void Func(void){ cout << “Func of class A” << endl; }
   };
   void Test(void)
   {
       A *p;
      {
         A a;
         p = &a; // 注意 a 的生命期 ，只在这个程序块中（花括号里面的两行），而不是整个test函数
      }
        p->Func();  // p是“野指针”
   }
   ```
   函数Test在执行语句p->Func()时，对象a已经消失，而p是指向a的，所以p就成了“野指针”。
   
