### **| 继承**
---
> c++ 的继承体现程序的复用性

#### **继承的格式**
```
class A{
    public:
    private:
    int a;
}

// B 继承于 A
class B : public A {
    public:
    private:
    int b;
}

//B中隐式的包含了A中的 数据和方法
```
- 通过定义的b对象 可以调用到A类中的成员方法和成员变量
#### **继承权限**
> 继承中有三种继承权限: public继承、protected继承、private继承
##### 继承权限表：

继承方式 访问权限 | 基类public成员|基类protected成员|基类private成员
|---:|---:|---:|---:|
|public继承|派生类public成员|派生类protected成员|派生类不可见|
|protected继承|派生类protected成员|派生类protected成员|派生类不可见|
|private继承|派生类private成员|派生类private成员|派生类不可见|

> 派生类中继承来的方法和数据的访问权限取决于 继承方式与基类中成员权限中较小的一个

- **基类的private成员已经被派生类继承下来，但是因为语法限制无论在类内外都不能访问，不论任何继承都无法访问**
- protected限定符表示在类外不可访问，在类中才可访问。保护成员限定符是因为继承才出现的。
- class中默认为private继承，struct中默认为public继承，一般最好显示写出继承方式
- public继承最为常用，private/protected继承只能在内中访问，作用不大

#### **派生类与基类间的类型转换**
##### 切片
>  将派生类的对象赋值给基类的对象/指针/引用，将派生类从基类继承来的再次赋值给基类
```
class person{
    protected:
    string name;
    int age;
}

class student : public person{

    protected:
    int stuid;
}
```
![image](https://user-images.githubusercontent.com/38885360/122239307-69109000-cef3-11eb-9442-45337005cd2c.png)
```
int main()
{

//可以将派生类对象赋值给基类对象，包括指针和引用
    student stu;
    person per = stu;
    person& per = stu;
    person* per = &stu;
}
```
   - 对象之间的赋值，是将派生类从基类继承来的数据复制一份给基类对象
   - 指针之间的赋值，是将基类的指针指向派生类的对象，但所指的范围只包括基类的数据
   - 引用之间的赋值，引用在底层也是一个指针，所以原理指针赋值的原理基本相同

>  基类的对象给派生类
```
    student stu;
	person per = stu;  
	person* per1 = &stu;
	person& per2 = stu;

    //基类对象和引用无法给派生类
	//stu = per;  //不可以
    //student& stu3 = per2; //不可以
    
    //指针可以转，但有条件
	student* stu1 = (student*)per1; //通过类型的强制转换可以将转换过的指针转换回去
	         stu1 = (student*)&per;//可以转换但会越界访问无法访问到student的数据

	person per3; 
	stu1 = (student*)&per3  //可以转换，会越界无法访问到student的数据是乱码
```
- 基类指针如果是由派生类的指针转换而来，那么可以通过强制的类型转换转回去
- 如果基类指针之前不是由派生类转换儿而来，那么可以强制转换，但会发生越界访问，只能访问到基类的数据，无法访问派生类数据，是乱码。

**基类和派生类之间的赋值转换只能发生在公有继承之间**

##### **隐藏(重定义)**

> 隐藏（重定义）：当派生类中与基类中存在同名数据或方法时就构成了隐藏，子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义。
- **当派生类对于同名的数据或者成员方法进行调用时只能调用到派生类的同名数据或者方法**
- 当要访问被隐藏的基类数据或方法，只能同过域名作用限定符访问**基类类名::数据**在子类中 进行显式访问
- 在基类和派生类中，只要函数名相同就构成了**隐藏**

##### **类的默认的成员函数在派生类与基类中的调用关系**

- 派生类的构造函数调用基类的构造函数来初始化继承自基类中的数据，如果基类中没有默认的构造函数，就在派生类构造的初始化列表阶段进行显式的调用。
- 派生类的拷贝构造调用基类的拷贝构造完成对基类数据的拷贝。
- 派生类的operator=调用基类的operator=完成对基类数据的赋值
- 派生类对象初始化先调用基类构造再调派生类构造
- **派生类对象析构清理先调用派生类析构再调基类的析构**

**先构造基类再构造派生类 先析构派生类再析构基类**
> 在函数栈帧的调用中，要符合先进后出的要求，符合栈的调用，所以先析构派生类，再析构基类。 在派生类的析构函数调用完后由编译器自动调用基类的析构函数。

#### **实现一个不能被继承的类**
- 将基类的构造函数私有化，将无法被继承
- c++11 使用final 关键字修饰类，则该类无法被继承

##### 继承中的友元关系
- 友元函数不能被继承，所以基类的友元无法访问派生类的私有和受保护成员
##### 继承中的static 
- 整个继承体系中只能有一个static成员，无论该基类派生出多少子类，都只能有一个static成员
- 所有子类对静态成员的操作都只是在同一个静态成员之上

### **｜多继承**
> c++ 中继承分为单继承和多继承
- 单继承：一个派生类只有一个基类
- 多继承：一个派生类不止有一个基类
    - 多继承中数据的二义性:当某个派生类继承的基类中拥有两份同样的数据成员拷贝时，派生类在使用时就容易导致二义性

#### **多继承中的菱形继承**
> 菱形继承是多继承中的一种复杂情况
![image](https://user-images.githubusercontent.com/38885360/122249903-d0cad900-cefb-11eb-8e1e-7e552314910f.png)
##### 菱形继承导致的两个问题
- 二义性：当使用A的数据时无法确定继承自B还是继承自C
- 数据冗余：类D中会有两份A的数据

##### 解决二义性
- 通过类名可以显式的指定调用哪一个类中的数据成员
```
class A{

public:
	int _a = 1;
};

class B : public A{

public:
	int _b = 2;
};

class C : public A{
public:
	
	int _c = 3;
};

class D : public B, public C {
public:

	int _d = 4;
};

int main(){
	D d1;
	//d1._a = 100;

	d1.B::_a = 100;  //可以显示的指定访问那一个类中的成员，解决了二义性问题
	d1.C::_a = 101;

}

```

##### 解决数据冗余的问题
> 通过虚拟继承可以解决菱形继承中的数据冗余的问题
- 通过菱形的虚拟继承，可以使该多继承体系中只有一份公共的A中的数据
```
//虚拟继承通过virtual关键字实现
class A{

public:
	int _a = 1;

class B : virtual public A{

public:
	int _b = 2;
};

class C : virtual public A{
public:
	
	int _c = 3;
};

class D : public B, public C {
public:

	int _d = 4;
};
```
##### 内存模型
![20181226131330291](https://user-images.githubusercontent.com/38885360/122320573-064fe080-cf55-11eb-8484-6b3797f98931.png)
- 多重继承的内存布局是按照声明顺序排列内存
##### **虚基表指针** ： 指向虚基表的指针
##### **虚基表** ： 存放当前位置到达存放公共基类数据位置的偏移量，通过该偏移量可以找到公共的基类数据成员

- 通过虚拟继承后，对象d 中将只会存在一份基类A的数据_a,原来存放继承自B和C类的_a的位置现在存放的则是虚基表指针，通过虚基表指针可以找到虚基表，获取到到达公共基类数据的偏移量，当前位置加上偏移量就可以访问到公共数据了


### ｜ 多态
--- 
### ｜ C 与 c++ 的联系
--- 
### ｜ C 实现 C++ 类
--- 